// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class UserMetadataByKey extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserMetadataByKey entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserMetadataByKey must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserMetadataByKey", id.toString(), this);
    }
  }

  static load(id: string): UserMetadataByKey | null {
    return changetype<UserMetadataByKey | null>(
      store.get("UserMetadataByKey", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get key(): Bytes {
    let value = this.get("key");
    return value!.toBytes();
  }

  set key(value: Bytes) {
    this.set("key", Value.fromBytes(value));
  }

  get value(): Bytes {
    let value = this.get("value");
    return value!.toBytes();
  }

  set value(value: Bytes) {
    this.set("value", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class UserMetadataEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserMetadataEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserMetadataEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserMetadataEvent", id.toString(), this);
    }
  }

  static load(id: string): UserMetadataEvent | null {
    return changetype<UserMetadataEvent | null>(
      store.get("UserMetadataEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get key(): Bytes {
    let value = this.get("key");
    return value!.toBytes();
  }

  set key(value: Bytes) {
    this.set("key", Value.fromBytes(value));
  }

  get value(): Bytes {
    let value = this.get("value");
    return value!.toBytes();
  }

  set value(value: Bytes) {
    this.set("value", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type User must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("User", id.toString(), this);
    }
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get assetConfigs(): Array<string> {
    let value = this.get("assetConfigs");
    return value!.toStringArray();
  }

  set assetConfigs(value: Array<string>) {
    this.set("assetConfigs", Value.fromStringArray(value));
  }

  get splitsEntryIds(): Array<string> {
    let value = this.get("splitsEntryIds");
    return value!.toStringArray();
  }

  set splitsEntryIds(value: Array<string>) {
    this.set("splitsEntryIds", Value.fromStringArray(value));
  }

  get splitsEntries(): Array<string> {
    let value = this.get("splitsEntries");
    return value!.toStringArray();
  }

  set splitsEntries(value: Array<string>) {
    this.set("splitsEntries", Value.fromStringArray(value));
  }

  get splitsReceiversHash(): Bytes {
    let value = this.get("splitsReceiversHash");
    return value!.toBytes();
  }

  set splitsReceiversHash(value: Bytes) {
    this.set("splitsReceiversHash", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class UserAssetConfig extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserAssetConfig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserAssetConfig must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserAssetConfig", id.toString(), this);
    }
  }

  static load(id: string): UserAssetConfig | null {
    return changetype<UserAssetConfig | null>(store.get("UserAssetConfig", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get streamsEntryIds(): Array<string> {
    let value = this.get("streamsEntryIds");
    return value!.toStringArray();
  }

  set streamsEntryIds(value: Array<string>) {
    this.set("streamsEntryIds", Value.fromStringArray(value));
  }

  get streamsEntries(): Array<string> {
    let value = this.get("streamsEntries");
    return value!.toStringArray();
  }

  set streamsEntries(value: Array<string>) {
    this.set("streamsEntries", Value.fromStringArray(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value!.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get assetConfigHash(): Bytes {
    let value = this.get("assetConfigHash");
    return value!.toBytes();
  }

  set assetConfigHash(value: Bytes) {
    this.set("assetConfigHash", Value.fromBytes(value));
  }

  get amountSplittable(): BigInt {
    let value = this.get("amountSplittable");
    return value!.toBigInt();
  }

  set amountSplittable(value: BigInt) {
    this.set("amountSplittable", Value.fromBigInt(value));
  }

  get amountPostSplitCollectable(): BigInt {
    let value = this.get("amountPostSplitCollectable");
    return value!.toBigInt();
  }

  set amountPostSplitCollectable(value: BigInt) {
    this.set("amountPostSplitCollectable", Value.fromBigInt(value));
  }

  get amountCollected(): BigInt {
    let value = this.get("amountCollected");
    return value!.toBigInt();
  }

  set amountCollected(value: BigInt) {
    this.set("amountCollected", Value.fromBigInt(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class StreamsSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StreamsSetEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StreamsSetEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StreamsSetEvent", id.toString(), this);
    }
  }

  static load(id: string): StreamsSetEvent | null {
    return changetype<StreamsSetEvent | null>(store.get("StreamsSetEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get StreamReceiverSeenEvents(): Array<string> {
    let value = this.get("StreamReceiverSeenEvents");
    return value!.toStringArray();
  }

  set StreamReceiverSeenEvents(value: Array<string>) {
    this.set("StreamReceiverSeenEvents", Value.fromStringArray(value));
  }

  get streamsHistoryHash(): Bytes {
    let value = this.get("streamsHistoryHash");
    return value!.toBytes();
  }

  set streamsHistoryHash(value: Bytes) {
    this.set("streamsHistoryHash", Value.fromBytes(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value!.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get maxEnd(): BigInt {
    let value = this.get("maxEnd");
    return value!.toBigInt();
  }

  set maxEnd(value: BigInt) {
    this.set("maxEnd", Value.fromBigInt(value));
  }
}

export class LastSetStreamUserMapping extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save LastSetStreamUserMapping entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LastSetStreamUserMapping must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LastSetStreamUserMapping", id.toString(), this);
    }
  }

  static load(id: string): LastSetStreamUserMapping | null {
    return changetype<LastSetStreamUserMapping | null>(
      store.get("LastSetStreamUserMapping", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get streamsSetEventId(): string {
    let value = this.get("streamsSetEventId");
    return value!.toString();
  }

  set streamsSetEventId(value: string) {
    this.set("streamsSetEventId", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }
}

export class StreamReceiverSeenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StreamReceiverSeenEvent entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StreamReceiverSeenEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StreamReceiverSeenEvent", id.toString(), this);
    }
  }

  static load(id: string): StreamReceiverSeenEvent | null {
    return changetype<StreamReceiverSeenEvent | null>(
      store.get("StreamReceiverSeenEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get streamsSetEvent(): string {
    let value = this.get("streamsSetEvent");
    return value!.toString();
  }

  set streamsSetEvent(value: string) {
    this.set("streamsSetEvent", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get senderUserId(): string {
    let value = this.get("senderUserId");
    return value!.toString();
  }

  set senderUserId(value: string) {
    this.set("senderUserId", Value.fromString(value));
  }

  get receiverUserId(): string {
    let value = this.get("receiverUserId");
    return value!.toString();
  }

  set receiverUserId(value: string) {
    this.set("receiverUserId", Value.fromString(value));
  }

  get config(): BigInt {
    let value = this.get("config");
    return value!.toBigInt();
  }

  set config(value: BigInt) {
    this.set("config", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class StreamsEntry extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StreamsEntry entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StreamsEntry must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StreamsEntry", id.toString(), this);
    }
  }

  static load(id: string): StreamsEntry | null {
    return changetype<StreamsEntry | null>(store.get("StreamsEntry", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): string {
    let value = this.get("sender");
    return value!.toString();
  }

  set sender(value: string) {
    this.set("sender", Value.fromString(value));
  }

  get senderAssetConfig(): string {
    let value = this.get("senderAssetConfig");
    return value!.toString();
  }

  set senderAssetConfig(value: string) {
    this.set("senderAssetConfig", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get config(): BigInt {
    let value = this.get("config");
    return value!.toBigInt();
  }

  set config(value: BigInt) {
    this.set("config", Value.fromBigInt(value));
  }
}

export class ReceivedStreamsEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ReceivedStreamsEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ReceivedStreamsEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ReceivedStreamsEvent", id.toString(), this);
    }
  }

  static load(id: string): ReceivedStreamsEvent | null {
    return changetype<ReceivedStreamsEvent | null>(
      store.get("ReceivedStreamsEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get amt(): BigInt {
    let value = this.get("amt");
    return value!.toBigInt();
  }

  set amt(value: BigInt) {
    this.set("amt", Value.fromBigInt(value));
  }

  get receivableCycles(): BigInt {
    let value = this.get("receivableCycles");
    return value!.toBigInt();
  }

  set receivableCycles(value: BigInt) {
    this.set("receivableCycles", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class SqueezedStreamsEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SqueezedStreamsEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SqueezedStreamsEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SqueezedStreamsEvent", id.toString(), this);
    }
  }

  static load(id: string): SqueezedStreamsEvent | null {
    return changetype<SqueezedStreamsEvent | null>(
      store.get("SqueezedStreamsEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get senderId(): string {
    let value = this.get("senderId");
    return value!.toString();
  }

  set senderId(value: string) {
    this.set("senderId", Value.fromString(value));
  }

  get amt(): BigInt {
    let value = this.get("amt");
    return value!.toBigInt();
  }

  set amt(value: BigInt) {
    this.set("amt", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get streamsHistoryHashes(): Array<Bytes> {
    let value = this.get("streamsHistoryHashes");
    return value!.toBytesArray();
  }

  set streamsHistoryHashes(value: Array<Bytes>) {
    this.set("streamsHistoryHashes", Value.fromBytesArray(value));
  }
}

export class SplitsSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SplitsSetEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SplitsSetEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SplitsSetEvent", id.toString(), this);
    }
  }

  static load(id: string): SplitsSetEvent | null {
    return changetype<SplitsSetEvent | null>(store.get("SplitsSetEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get splitsReceiverSeenEvents(): Array<string> {
    let value = this.get("splitsReceiverSeenEvents");
    return value!.toStringArray();
  }

  set splitsReceiverSeenEvents(value: Array<string>) {
    this.set("splitsReceiverSeenEvents", Value.fromStringArray(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class LastSetSplitsUserMapping extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save LastSetSplitsUserMapping entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LastSetSplitsUserMapping must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LastSetSplitsUserMapping", id.toString(), this);
    }
  }

  static load(id: string): LastSetSplitsUserMapping | null {
    return changetype<LastSetSplitsUserMapping | null>(
      store.get("LastSetSplitsUserMapping", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get splitsSetEventId(): string {
    let value = this.get("splitsSetEventId");
    return value!.toString();
  }

  set splitsSetEventId(value: string) {
    this.set("splitsSetEventId", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }
}

export class SplitsReceiverSeenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SplitsReceiverSeenEvent entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SplitsReceiverSeenEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SplitsReceiverSeenEvent", id.toString(), this);
    }
  }

  static load(id: string): SplitsReceiverSeenEvent | null {
    return changetype<SplitsReceiverSeenEvent | null>(
      store.get("SplitsReceiverSeenEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get splitsSetEvent(): string {
    let value = this.get("splitsSetEvent");
    return value!.toString();
  }

  set splitsSetEvent(value: string) {
    this.set("splitsSetEvent", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get senderUserId(): string {
    let value = this.get("senderUserId");
    return value!.toString();
  }

  set senderUserId(value: string) {
    this.set("senderUserId", Value.fromString(value));
  }

  get receiverUserId(): string {
    let value = this.get("receiverUserId");
    return value!.toString();
  }

  set receiverUserId(value: string) {
    this.set("receiverUserId", Value.fromString(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class SplitsEntry extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SplitsEntry entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SplitsEntry must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SplitsEntry", id.toString(), this);
    }
  }

  static load(id: string): SplitsEntry | null {
    return changetype<SplitsEntry | null>(store.get("SplitsEntry", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): string {
    let value = this.get("sender");
    return value!.toString();
  }

  set sender(value: string) {
    this.set("sender", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }
}

export class SplitEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SplitEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SplitEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SplitEvent", id.toString(), this);
    }
  }

  static load(id: string): SplitEvent | null {
    return changetype<SplitEvent | null>(store.get("SplitEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get receiverId(): string {
    let value = this.get("receiverId");
    return value!.toString();
  }

  set receiverId(value: string) {
    this.set("receiverId", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get amt(): BigInt {
    let value = this.get("amt");
    return value!.toBigInt();
  }

  set amt(value: BigInt) {
    this.set("amt", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CollectableEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CollectableEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CollectableEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CollectableEvent", id.toString(), this);
    }
  }

  static load(id: string): CollectableEvent | null {
    return changetype<CollectableEvent | null>(
      store.get("CollectableEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get amt(): BigInt {
    let value = this.get("amt");
    return value!.toBigInt();
  }

  set amt(value: BigInt) {
    this.set("amt", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CollectedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CollectedEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CollectedEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CollectedEvent", id.toString(), this);
    }
  }

  static load(id: string): CollectedEvent | null {
    return changetype<CollectedEvent | null>(store.get("CollectedEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get collected(): BigInt {
    let value = this.get("collected");
    return value!.toBigInt();
  }

  set collected(value: BigInt) {
    this.set("collected", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class GivenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GivenEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GivenEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GivenEvent", id.toString(), this);
    }
  }

  static load(id: string): GivenEvent | null {
    return changetype<GivenEvent | null>(store.get("GivenEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get receiverUserId(): string {
    let value = this.get("receiverUserId");
    return value!.toString();
  }

  set receiverUserId(value: string) {
    this.set("receiverUserId", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get amt(): BigInt {
    let value = this.get("amt");
    return value!.toBigInt();
  }

  set amt(value: BigInt) {
    this.set("amt", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class App extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save App entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type App must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("App", id.toString(), this);
    }
  }

  static load(id: string): App | null {
    return changetype<App | null>(store.get("App", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get appAddress(): Bytes {
    let value = this.get("appAddress");
    return value!.toBytes();
  }

  set appAddress(value: Bytes) {
    this.set("appAddress", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class NFTSubAccount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NFTSubAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NFTSubAccount must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NFTSubAccount", id.toString(), this);
    }
  }

  static load(id: string): NFTSubAccount | null {
    return changetype<NFTSubAccount | null>(store.get("NFTSubAccount", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get ownerAddress(): Bytes {
    let value = this.get("ownerAddress");
    return value!.toBytes();
  }

  set ownerAddress(value: Bytes) {
    this.set("ownerAddress", Value.fromBytes(value));
  }
}

export class ImmutableSplitsCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ImmutableSplitsCreated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ImmutableSplitsCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ImmutableSplitsCreated", id.toString(), this);
    }
  }

  static load(id: string): ImmutableSplitsCreated | null {
    return changetype<ImmutableSplitsCreated | null>(
      store.get("ImmutableSplitsCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): string {
    let value = this.get("userId");
    return value!.toString();
  }

  set userId(value: string) {
    this.set("userId", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }
}

export class RepoAccount extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RepoAccount entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RepoAccount must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RepoAccount", id.toString(), this);
    }
  }

  static load(id: string): RepoAccount | null {
    return changetype<RepoAccount | null>(store.get("RepoAccount", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get forge(): BigInt {
    let value = this.get("forge");
    return value!.toBigInt();
  }

  set forge(value: BigInt) {
    this.set("forge", Value.fromBigInt(value));
  }

  get status(): string | null {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set status(value: string | null) {
    if (!value) {
      this.unset("status");
    } else {
      this.set("status", Value.fromString(<string>value));
    }
  }

  get ownerAddress(): string | null {
    let value = this.get("ownerAddress");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set ownerAddress(value: string | null) {
    if (!value) {
      this.unset("ownerAddress");
    } else {
      this.set("ownerAddress", Value.fromString(<string>value));
    }
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}
