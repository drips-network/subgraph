// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("splitsEntryIds", Value.fromStringArray(new Array(0)));
    this.set("splitsReceiversHash", Value.fromBytes(Bytes.empty()));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save User entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("User", id.toString(), this);
    }
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get assetConfigs(): Array<string> {
    let value = this.get("assetConfigs");
    return value!.toStringArray();
  }

  set assetConfigs(value: Array<string>) {
    this.set("assetConfigs", Value.fromStringArray(value));
  }

  get splitsEntryIds(): Array<string> {
    let value = this.get("splitsEntryIds");
    return value!.toStringArray();
  }

  set splitsEntryIds(value: Array<string>) {
    this.set("splitsEntryIds", Value.fromStringArray(value));
  }

  get splitsEntries(): Array<string> {
    let value = this.get("splitsEntries");
    return value!.toStringArray();
  }

  set splitsEntries(value: Array<string>) {
    this.set("splitsEntries", Value.fromStringArray(value));
  }

  get splitsReceiversHash(): Bytes {
    let value = this.get("splitsReceiversHash");
    return value!.toBytes();
  }

  set splitsReceiversHash(value: Bytes) {
    this.set("splitsReceiversHash", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class UserAssetConfig extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromString(""));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("dripsEntryIds", Value.fromStringArray(new Array(0)));
    this.set("balance", Value.fromBigInt(BigInt.zero()));
    this.set("assetConfigHash", Value.fromBytes(Bytes.empty()));
    this.set("amountCollected", Value.fromBigInt(BigInt.zero()));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserAssetConfig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save UserAssetConfig entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("UserAssetConfig", id.toString(), this);
    }
  }

  static load(id: string): UserAssetConfig | null {
    return changetype<UserAssetConfig | null>(store.get("UserAssetConfig", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get dripsEntryIds(): Array<string> {
    let value = this.get("dripsEntryIds");
    return value!.toStringArray();
  }

  set dripsEntryIds(value: Array<string>) {
    this.set("dripsEntryIds", Value.fromStringArray(value));
  }

  get dripsEntries(): Array<string> {
    let value = this.get("dripsEntries");
    return value!.toStringArray();
  }

  set dripsEntries(value: Array<string>) {
    this.set("dripsEntries", Value.fromStringArray(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value!.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get assetConfigHash(): Bytes {
    let value = this.get("assetConfigHash");
    return value!.toBytes();
  }

  set assetConfigHash(value: Bytes) {
    this.set("assetConfigHash", Value.fromBytes(value));
  }

  get amountCollected(): BigInt {
    let value = this.get("amountCollected");
    return value!.toBigInt();
  }

  set amountCollected(value: BigInt) {
    this.set("amountCollected", Value.fromBigInt(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class DripsSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("receiversHash", Value.fromBytes(Bytes.empty()));
    this.set("balance", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DripsSetEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DripsSetEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DripsSetEvent", id.toString(), this);
    }
  }

  static load(id: string): DripsSetEvent | null {
    return changetype<DripsSetEvent | null>(store.get("DripsSetEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value!.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class HashToDripsSetDetail extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("currentDripsSetEvent", Value.fromString(""));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HashToDripsSetDetail entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save HashToDripsSetDetail entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("HashToDripsSetDetail", id.toString(), this);
    }
  }

  static load(id: string): HashToDripsSetDetail | null {
    return changetype<HashToDripsSetDetail | null>(
      store.get("HashToDripsSetDetail", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get currentDripsSetEvent(): string {
    let value = this.get("currentDripsSetEvent");
    return value!.toString();
  }

  set currentDripsSetEvent(value: string) {
    this.set("currentDripsSetEvent", Value.fromString(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class DripsReceiverSeenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("receiversHash", Value.fromBytes(Bytes.empty()));
    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("config", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DripsReceiverSeenEvent entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DripsReceiverSeenEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DripsReceiverSeenEvent", id.toString(), this);
    }
  }

  static load(id: string): DripsReceiverSeenEvent | null {
    return changetype<DripsReceiverSeenEvent | null>(
      store.get("DripsReceiverSeenEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get config(): BigInt {
    let value = this.get("config");
    return value!.toBigInt();
  }

  set config(value: BigInt) {
    this.set("config", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class DripsEntry extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromString(""));
    this.set("senderAssetConfig", Value.fromString(""));
    this.set("receiverUserId", Value.fromBigInt(BigInt.zero()));
    this.set("config", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DripsEntry entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save DripsEntry entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("DripsEntry", id.toString(), this);
    }
  }

  static load(id: string): DripsEntry | null {
    return changetype<DripsEntry | null>(store.get("DripsEntry", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): string {
    let value = this.get("sender");
    return value!.toString();
  }

  set sender(value: string) {
    this.set("sender", Value.fromString(value));
  }

  get senderAssetConfig(): string {
    let value = this.get("senderAssetConfig");
    return value!.toString();
  }

  set senderAssetConfig(value: string) {
    this.set("senderAssetConfig", Value.fromString(value));
  }

  get receiverUserId(): BigInt {
    let value = this.get("receiverUserId");
    return value!.toBigInt();
  }

  set receiverUserId(value: BigInt) {
    this.set("receiverUserId", Value.fromBigInt(value));
  }

  get config(): BigInt {
    let value = this.get("config");
    return value!.toBigInt();
  }

  set config(value: BigInt) {
    this.set("config", Value.fromBigInt(value));
  }
}

export class SplitsSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("receiversHash", Value.fromBytes(Bytes.empty()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SplitsSetEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SplitsSetEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SplitsSetEvent", id.toString(), this);
    }
  }

  static load(id: string): SplitsSetEvent | null {
    return changetype<SplitsSetEvent | null>(store.get("SplitsSetEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class HashToSplitsSetDetail extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save HashToSplitsSetDetail entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save HashToSplitsSetDetail entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("HashToSplitsSetDetail", id.toString(), this);
    }
  }

  static load(id: string): HashToSplitsSetDetail | null {
    return changetype<HashToSplitsSetDetail | null>(
      store.get("HashToSplitsSetDetail", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class SplitsReceiverSeenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("receiversHash", Value.fromBytes(Bytes.empty()));
    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("weight", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SplitsReceiverSeenEvent entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SplitsReceiverSeenEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SplitsReceiverSeenEvent", id.toString(), this);
    }
  }

  static load(id: string): SplitsReceiverSeenEvent | null {
    return changetype<SplitsReceiverSeenEvent | null>(
      store.get("SplitsReceiverSeenEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get receiversHash(): Bytes {
    let value = this.get("receiversHash");
    return value!.toBytes();
  }

  set receiversHash(value: Bytes) {
    this.set("receiversHash", Value.fromBytes(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class SplitsEntry extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("sender", Value.fromString(""));
    this.set("receiverUserId", Value.fromBigInt(BigInt.zero()));
    this.set("weight", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SplitsEntry entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SplitsEntry entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SplitsEntry", id.toString(), this);
    }
  }

  static load(id: string): SplitsEntry | null {
    return changetype<SplitsEntry | null>(store.get("SplitsEntry", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get sender(): string {
    let value = this.get("sender");
    return value!.toString();
  }

  set sender(value: string) {
    this.set("sender", Value.fromString(value));
  }

  get receiverUserId(): BigInt {
    let value = this.get("receiverUserId");
    return value!.toBigInt();
  }

  set receiverUserId(value: BigInt) {
    this.set("receiverUserId", Value.fromBigInt(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }
}

export class CollectedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("user", Value.fromString(""));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("collected", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CollectedEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save CollectedEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("CollectedEvent", id.toString(), this);
    }
  }

  static load(id: string): CollectedEvent | null {
    return changetype<CollectedEvent | null>(store.get("CollectedEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get collected(): BigInt {
    let value = this.get("collected");
    return value!.toBigInt();
  }

  set collected(value: BigInt) {
    this.set("collected", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class IdentityMetaData extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("key", Value.fromBytes(Bytes.empty()));
    this.set("multiHash", Value.fromBytes(Bytes.empty()));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IdentityMetaData entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IdentityMetaData entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IdentityMetaData", id.toString(), this);
    }
  }

  static load(id: string): IdentityMetaData | null {
    return changetype<IdentityMetaData | null>(
      store.get("IdentityMetaData", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get key(): Bytes {
    let value = this.get("key");
    return value!.toBytes();
  }

  set key(value: Bytes) {
    this.set("key", Value.fromBytes(value));
  }

  get multiHash(): Bytes {
    let value = this.get("multiHash");
    return value!.toBytes();
  }

  set multiHash(value: Bytes) {
    this.set("multiHash", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}

export class GivenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("userId", Value.fromBigInt(BigInt.zero()));
    this.set("receiverUserId", Value.fromBigInt(BigInt.zero()));
    this.set("assetId", Value.fromBigInt(BigInt.zero()));
    this.set("amt", Value.fromBigInt(BigInt.zero()));
    this.set("blockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GivenEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save GivenEvent entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("GivenEvent", id.toString(), this);
    }
  }

  static load(id: string): GivenEvent | null {
    return changetype<GivenEvent | null>(store.get("GivenEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userId(): BigInt {
    let value = this.get("userId");
    return value!.toBigInt();
  }

  set userId(value: BigInt) {
    this.set("userId", Value.fromBigInt(value));
  }

  get receiverUserId(): BigInt {
    let value = this.get("receiverUserId");
    return value!.toBigInt();
  }

  set receiverUserId(value: BigInt) {
    this.set("receiverUserId", Value.fromBigInt(value));
  }

  get assetId(): BigInt {
    let value = this.get("assetId");
    return value!.toBigInt();
  }

  set assetId(value: BigInt) {
    this.set("assetId", Value.fromBigInt(value));
  }

  get amt(): BigInt {
    let value = this.get("amt");
    return value!.toBigInt();
  }

  set amt(value: BigInt) {
    this.set("amt", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class App extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("appAddress", Value.fromBytes(Bytes.empty()));
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save App entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save App entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("App", id.toString(), this);
    }
  }

  static load(id: string): App | null {
    return changetype<App | null>(store.get("App", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get appAddress(): Bytes {
    let value = this.get("appAddress");
    return value!.toBytes();
  }

  set appAddress(value: Bytes) {
    this.set("appAddress", Value.fromBytes(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    return value!.toBigInt();
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }
}
